SPECIFICATION Spec

\* Temporals as properties (for liveness checks; TLC with -deadlock or Apalache)
PROPERTY Progress FastPathLiveness BoundedFinalization LivenessResilient PartitionRecovery

\* State invariants (safety/resilience)
INVARIANT TypeOK NoConflicts ChainConsistency CertUnique SafetyResilient DeliveryInvariant CertUniqueness

CONSTANTS
  Nodes = {n1, n2, n3, n4, n5, n6, n7, n8}  \* 8 nodes for exhaustive small config (4-10 as required)
  Stake = [n \in Nodes |-> 1]  \* Uniform stake for simplicity; total=8
  TotalStake = 8
  ByzantineThreshold = 1  \* ~12.5% stake <20%; adjust for tests
  OfflineThreshold = 1  \* ~12.5% stake <20%
  ByzantineNodes = {}  \* Base: no faults; override e.g. {n1} for 12.5% Byzantine stake
  OfflineNodes = {}  \* Base: no offline; override for resilience checks
  GST = 100
  SlotTime = 400
  Delta80 = 150
  Delta60 = 200
  ErasureThreshold = 5  \* Example for Rotor decoding (e.g., 5/8 shreds)

\* Abstract leader schedule (stake-weighted in full; functional here)
Leaders = [s \in Nat |-> IF s % 8 = 0 THEN n1 ELSE n(s % 8 + 1)]

SYMMETRY modelSymmetry  \* Reduce states with node permutations (define in tla: modelSymmetry == Permutations(Nodes))
VIEW stateView  \* Optional: Define view == <<slots, finalized>> to collapse equivalents

CHECK_DEADLOCK FALSE  \* Allow for liveness paths
DEPTH 50  \* Bound for feasible runs on large spaces

\* For fault/resilience runs: Override ByzantineNodes = {n1}, OfflineNodes = {n2} in separate cfgs
\* For statistical/large: Use Apalache with --length=100 --cinit=ConstInit --inv=... (separate tool)
